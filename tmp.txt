// func (MySqlDB) Connect() {
// 	db, err := sql.Open("mysql", "fin_paul:3CzjWc#JY$i@hr@tcp(35.189.162.52:3306)/msqdbt1?charset=utf8")
// 	if err != nil {
// 		fmt.Println("err is: ", err)
// 	}
// 	defer db.Close()
// 	err = db.Ping()

// 	rows, err2 := db.Query(`SELECT * FROM orders o WHERE o.id = 375 OR o.id = 376;`)

// 	defer rows.Close()
// 	if err2 != nil {
// 		fmt.Println("err2 is: ", err2)
// 	}

// 	cols, _ := rows.Columns()
// 	// fmt.Println("this is cols: ", cols)

// 	values := make([]sql.RawBytes, len(cols))
// 	scans := make([]interface{}, len(cols))
// 	// fmt.Println("this is values: ", values)
// 	for i := range values {
// 		scans[i] = &values[i]
// 	}
// 	// fmt.Println("this is values2: ", values)
// 	results := make(map[int]map[string]string)

// 	i := 0

// 	for rows.Next() {
// 		if err := rows.Scan(scans...); err != nil {
// 			fmt.Println("Error")
// 			return
// 		}
// 		// fmt.Println("this is values3: ", values)
// 		row := make(map[string]string)
// 		for j, v := range values {
// 			fmt.Println("this is j: ", j)
// 			fmt.Println("this is v: ", string(v))
// 			key := cols[j]
// 			row[key] = string(v)
// 		}
// 		results[i] = row
// 		i++
// 	}

// 	// 打印结果
// 	for _, m := range results {
// 		// fmt.Println(i)
// 		for k, v := range m {
// 			fmt.Println("this is record value -- ", k, " : ", v)
// 		}
// 		fmt.Println("========================")
// 	}
// }

// func (MySqlDB) FindOrder() {

// }

// func (MySqlDB) Operate() {

// }

// db, err := gorm.Open("mysql", "fin_paul:3CzjWc#JY$i@hr@tcp(35.189.162.52:3306)/msqdbt1?charset=utf8")
//  else {
// 	fmt.Println("connect msqdbt1 sucessed")
// }

// orders := schema.Orders{}

// db.Where("id = ?", 375).Find(&orders)
// fmt.Println("this is orders: ", orders.Amount)

// return db





// // ParkingRecordOperator :
// type ParkingRecordOperator struct{}
// // ParkingRecordDetailOperator :
// type ParkingRecordDetailOperator struct{}

// func (ParkingRecordOperator) GetByExitedAt(d *gorm.DB, start time.Time, end time.Time) []schema.ParkingRecord {
// 	defer d.Close()
// 	var parkingRecord []schema.ParkingRecord
// 	d.Find(&parkingRecord, "exited_at >= ? AND exited_at <= ?", start, end)

// 	return parkingRecord
// }

// func (ParkingRecordDetailOperator) GetByParkingRecordID(d *gorm.DB, prID []int) []schema.ParkingRecordDetails {
// 	defer d.Close()
// 	var parkingRecordDetails []schema.ParkingRecordDetails
// 	d.Find(&parkingRecordDetails, "parking_record_id in (?)", prID)

// 	return parkingRecordDetails
// }

// `SELECT * FROM msqdbt1.orders od
// INNER JOIN msqdbt1.parking_record_details  prd
// ON od.id=prd.order_id
// INNER JOIN msqdbt1.parking_records pr
// ON prd.parking_record_id=pr.id
// WHERE od.STATUS IN (1,2,3,4)
// AND
// (
// 	(
// 		DATE_FORMAT(DATE_ADD(pr.exited_at,INTERVAL 8 HOUR),'%Y-%m')='2018-01'
// 		AND DATE_ADD(od.created_at,INTERVAL 8 HOUR) <='2018-02-04'
// 	)
//    OR  (
// 		DATE_FORMAT(DATE_ADD(pr.exited_at,INTERVAL 8 HOUR),'%Y-%m')='2017-12'
// 		AND
// 		(
// 			(
// 			 DATE_ADD(od.created_at,INTERVAL 8 HOUR) <='2018-02-04'
// 			 AND DATE_ADD(od.created_at,INTERVAL 8 HOUR) >'2018-01-04'
// 			)
// 			OR
// 			(
// 				 DATE_ADD(od.refund_time,INTERVAL 8 HOUR) >'2018-01-04'
// 				AND DATE_ADD(od.refund_time,INTERVAL 8 HOUR) <='2018-02-04'
// 			)
// 		)
// 	)
// )`




// // Orders : msqdbt1.orders schema
// type Orders struct {
// 	ID            int `gorm:"primary_key"`
// 	Status        int
// 	Amount        int
// 	CreatedAt     time.Time
// 	OrderNum      string
// 	PaidAmount    int
// 	PaymentStatus int
// 	InvoiceStatus int
// 	CaptureTime   *time.Time
// 	RefundTime    *time.Time
// 	OrderNumMom   string
// 	AccountID     int
// }

// // ParkingRecordDetails : msqdbt1.parkingRecordDetails schema
// type ParkingRecordDetails struct {
// 	ID              int `gorm:"primary_key"`
// 	OrderID         int
// 	ParkingRecordID int
// 	Orders          Orders
// 	ParkingRecord   ParkingRecord
// }

// // ParkingRecord : msqdbt1.parkingRecord schema
// type ParkingRecord struct {
// 	ID         int `gorm:"primary_key"`
// 	EnteredAt  *time.Time
// 	ExitedAt   *time.Time
// 	LotCode    string
// 	EntryType  int
// 	EntryValue string
// }
